[README.md](https://github.com/user-attachments/files/21804338/README.md)
# bertoti
Banco de Dados 2/2025 (Engeharia de Software)

1. Comentar com suas palavras o primeiro trecho do livro Software Engineering at Google, Oreilly.
   
   R: O texto amplia o conceito de engenharia de software para incluir não apenas a escrita de código, mas também todos os processos e ferramentas necessários para manter esse código valioso ao longo do tempo. A ideia central é que engenharia de software é “programação integrada ao longo do tempo”, ou seja, não basta criar — é preciso garantir que o software possa evoluir, se adaptar e ser mantido durante todo o seu ciclo de vida, desde a concepção até sua desativação. O trecho destaca três princípios fundamentais: **Tempo e Mudança** (como o código precisará se adaptar), **Escala e Crescimento** (como a organização precisa evoluir) e **Trade-offs e Custos** (como tomar decisões equilibrando esses fatores). A visão é de que um bom software não é apenas bem feito no início, mas preparado para durar e se ajustar às mudanças inevitáveis.

2. Comentar com suas palavras o segundo trecho do livro Software Engineering at Google, Oreilly.

   R: O texto diferencia claramente **programação** de **engenharia de software**. Programar é escrever código para resolver problemas, enquanto engenharia de software vai além, exigindo métodos mais rigorosos, semelhantes a outras engenharias, para criar soluções robustas e confiáveis. A comparação com áreas como engenharia mecânica ou civil mostra que, nessas áreas, práticas e normas rigorosas já são obrigatórias devido às consequências de erros. Embora a programação não tenha historicamente seguido esse nível de disciplina, o crescimento da dependência de software na sociedade exige que adotemos práticas mais estruturadas e profissionais. O objetivo é que o desenvolvimento de software seja tão confiável quanto o de outras engenharias.

3. Exemplos de trade-offs em engenharia de software:

   R:**Desempenho vs. Manutenção**  
   Otimizar ao máximo pode deixar o código mais rápido, mas também mais complexo e difícil de entender.  
   Exemplo: usar algoritmos altamente eficientes, porém pouco legíveis, que dificultam a manutenção por novos desenvolvedores.

    **Tempo de entrega vs. Qualidade**  
   Lançar rápido pode significar cortar testes e revisões, o que aumenta riscos de bugs e falhas.  
   Exemplo: entregar uma nova funcionalidade em uma semana para atender a demanda do cliente, mas ter que corrigir diversos problemas depois.

   **Segurança vs. Usabilidade**  
   Aumentar a segurança pode tornar o uso menos prático para o usuário.  
   Exemplo: exigir autenticação em dois fatores em cada acesso aumenta a proteção, mas pode irritar usuários que precisam acessar o sistema várias vezes ao dia.
